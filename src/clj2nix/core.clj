(ns clj2nix.core
  (:gen-class)
  (:require [clojure.tools.deps.alpha :as deps]
            [clojure.tools.deps.alpha.util.maven :as mvn]
            [clojure.tools.cli :refer [parse-opts]]
            [clojure.string :as string]
            [clojure.edn :as edn]
            [clojure.data.json :as json]
            [clojure.java.io :as io]
            [clojure.java.shell :refer [sh]]
            [clojure.string :as str]))

(defn- autogenerate-comment [clj2nix-version]
  (str "# generated by clj2nix-" clj2nix-version "\n"))

(defn- repos-nix [mvn-repos]
  (->> mvn-repos
       (map #(-> % (second) :url))
       (map #(str "        \"" % \"))
       (string/join "\n" )
       (str "\n")))

(defn- prefix [{:keys [mvn-repos]}]
  (str "{ fetchMavenArtifact, fetchgit, lib }:

let repos = [" (repos-nix mvn-repos) " ];

  in rec {
      makePaths = {extraClasspaths ? []}:
        if (builtins.typeOf extraClasspaths != \"list\")
        then builtins.throw \"extraClasspaths must be of type 'list'!\"
        else (lib.concatMap (dep:
          builtins.map (path:
            if builtins.isString path then
              path
            else if builtins.hasAttr \"jar\" path then
              path.jar
            else if builtins.hasAttr \"outPath\" path then
              path.outPath
            else
              path
            )
          dep.paths)
        packages) ++ extraClasspaths;
      makeClasspaths = {extraClasspaths ? []}:
       if (builtins.typeOf extraClasspaths != \"list\")
       then builtins.throw \"extraClasspaths must be of type 'list'!\"
       else builtins.concatStringsSep \":\" (makePaths {inherit extraClasspaths;});
      packageSources = builtins.map (dep: dep.src) packages;
      packages = ["))

(def ^:priave suffix
  "
  ];
  }
  ")

(defn- maven-item [artifactID groupID sha512 version classifier]
  (let [name (str artifactID "/" groupID)
        classifier-str
        (if-not classifier
          ""
          (format "classifier = \"%s\";" classifier))]
   (format "
  rec {
    name = \"%s\";
    src = fetchMavenArtifact {
      inherit repos;
      artifactId = \"%s\";
      groupId = \"%s\";
      sha512 = \"%s\";
      version = \"%s\";
      %s
    };
    paths = [ src ];
  }
" name artifactID groupID sha512 (str version) classifier-str)))

(defn- git-source-paths [{:keys [paths] :deps/keys [root]}]
  (map #(str/replace-first % root "") paths))

(defn- git-item [name artifactID url rev sha256 source-paths]
  (format "
  (rec {
    name = \"%s\";
    src = fetchgit {
      name = \"%s\";
      url = \"%s\";
      rev = \"%s\";
      sha256 = \"%s\";
    };
    paths = map (path: src + path) [
      %s
    ];
  })
" (str name) artifactID url rev sha256
          (->> source-paths
               (map #(format "\"%s\"" %))
               (str/join "\n        "))))

(defn- resolve-artifact-and-group [name]
  (let [split (string/split (str name) #"/")
        [name classifier]
        (if (= 1 (count split))
          (string/split (str name) #"\$")
          (string/split (second split) #"\$"))]
    (if (= 1 (count split))
      [name name classifier]
      [(first split) name classifier])))

(defn- resolve-git-sha256 [git-url rev]
  (let [unpack? (or (re-find #"\.tar.gz$" git-url)
                    (re-find #"\.zip$" git-url)
                    (re-find #"\.tar$" git-url))
        result  (:out (sh "nix-prefetch-git"
                          "--url" git-url
                          "--rev" rev))]
    (get (json/read-str result) "sha256")))

(defn- resolve-sha512 [filepath]
  (assert (.exists (io/as-file filepath))
          (str filepath " " "doesn't exists."))
  (subs (:out (sh "sha512sum" filepath)) 0 128))

(defn- generate-items [deps]
  (->> (seq deps)
       (reduce (fn [acc [name dep]]
                 (let [[groupID artifactID classifier] (resolve-artifact-and-group name)]
                   (let [git-dep?   (contains? dep :git/url)
                         local-dep? (contains? dep :local/root)]
                     (assert (contains? dep :paths)
                             (str name " has not been fetched locally."
                                  " Make sure that all dependencies exist locally."))
                     (cond
                       local-dep? (do (println "Warning: " name
                                               " is a local dependency."
                                               " All its remote dependencies will "
                                               " be resolved, but you need to add the "
                                               " jar/dir manually as a source to your "
                                               " nix-expression for it to be included."
                                               " As well as append its classpath via the "
                                               " argument extraClasspaths in "
                                               " makeClasspaths if needed.")
                                      acc)
                       git-dep?  (conj
                                   acc
                                   (git-item name
                                             artifactID
                                             (:git/url dep)
                                             (or (:sha dep) (:git/sha dep))
                                             (resolve-git-sha256 (:git/url dep) (or (:sha dep) (:git/sha dep)))
                                             (git-source-paths dep)))
                       :else      (conj
                                   acc
                                   (maven-item artifactID
                                               groupID
                                               (resolve-sha512 (first (:paths dep)))
                                               (:mvn/version dep)
                                               classifier)))))) [])
       (apply str)))

(defn generate-nix-expr
  [{:keys [version resolved-deps mvn-repos]}]
  (str (autogenerate-comment (or version "dev"))
       (prefix {:mvn-repos mvn-repos})
       (generate-items resolved-deps)
       suffix))

(defn- usage []
  (->> ["clj2nix"
        ""
        "Usage: clj2nix deps.edn deps.nix [options]"
        ""
        "Options:"
        "  -Aalias    read deps from an alias and append it to the classpath"
        ""
        "Please report bugs to https://github.com/hlolli/clj2nix"]
       (string/join "\n")))

(def ^:private cli-options
  [["-A" "--alias ALIAS" "Alias name"
    :default []
    :parse-fn #(if (= \: (first %))
                 (read-string %)
                 (identity %))
    :assoc-fn (fn [m id value] (update m id conj value))
    :validate [#(or (keyword? %) (and (string? %) (< 0 (count %))))
               "An alias can't be empty value and must either be a keyword or symbol"]]
   ["-h" "--help"]])

(defn -main [clj2nix-version deps-edn-path output-path & opts]
  (let [{:keys [options summary errors] :as parsed-args}
        (parse-opts (into [] (or opts [])) cli-options)
        deps-edn-data (edn/read-string (slurp deps-edn-path))
        mvn-repos (get deps-edn-data :mvn/repos mvn/standard-repos)
        aliases (->> (:alias options)
                     (map (fn [alias] (get-in deps-edn-data [:aliases alias])))
                     (map (fn [alias-data] (:extra-deps alias-data)))
                     (remove nil?)
                     (into []))
        deps-to-resolve (into (or (:deps deps-edn-data) {})
                              (reduce into [] aliases))
        deps-edn-data (assoc deps-edn-data
                             :deps deps-to-resolve
                             :mvn/repos mvn-repos)]
    (when (some #(not (contains? (:aliases deps-edn-data) %)) (:alias options))
      (println "Warning: non-existent alias was provided"
               (remove #(get (into #{} (keys (:aliases deps-edn-data))) %) (:alias options))))
    (cond
      errors (println "Error in clj2nix options:" errors)
      (:help options) (println (usage))
      :else (spit
             output-path
             (generate-nix-expr
              {:version clj2nix-version
               :resolved-deps (deps/resolve-deps deps-edn-data nil)
               :mvn-repos mvn-repos}))))
  (System/exit 0))


(comment
  (do (spit "debug.nix"
            (generate-nix-expr
             (deps/resolve-deps
              '{:deps
                {org.clojure/clojure        {:mvn/version "1.9.0"}
                 org.clojure/clojurescript  {:mvn/version "1.10.238"}
                 org.clojure/tools.reader   {:mvn/version "1.3.0-alpha3"}
                 com.cognitect/transit-cljs {:mvn/version "0.8.256"}
                 malabarba/lazy-map         {:mvn/version "1.3"}
                 fipp                       {:mvn/version "0.6.12"}
                 clj-time                   {:mvn/version "0.14.2"}}}
              nil
              )))
      (System/exit 0)))
